function [matched_df1, matched_df2, distances] = point_matching_model(df1, df2, F, thresh)
    
    % Create copies of df1, df2 without time, and with 1s in (:,3) spot
    df1_ec = df1(:, 1:2);
    df2_ec = df2(:, 1:2);
    % Setting up to solve epipolar constraint problem
    df1_ec(:,3) = 1;
    df2_ec(:,3) = 1;
    
    distances = dist2line(df1_ec, df2_ec, F);
    %disp(distances)
    #disp(matchpairs(distances, thresh))
    
    % Send in df1 and df2 (instead of the epipolar constraint (ec)
    % counterparts) to slice including times 
    [matched_df1,matched_df2] = findMatches(df1, df2, distances, 100);
    disp([matched_df1,matched_df2])

end

function [matched_df1,matched_df2] = findMatches(df1,df2,distances,threshold)
    % Applies the Hungarian / Munkres algorithm to solve the assignment
    % problem between points and lines. Specifically solving the 
    % unbalanced assignment problem. See Matlab documentation for
    % matchmpair:    https://web.archive.org/web/20230228044014/https://www.mathworks.com/help/matlab/ref/matchpairs.html
    % Threshold is the maximum distance separation between lines and points
    % before no solution is returned. IE with a threshold of 5, any
    % minimum distanes above 5 will not be returned as a solution.
    M = matchpairs(distances,threshold);
    %pairs = zeros(size(M,1),4);
    matched_df1 = zeros(size(M,1), 2);
    matched_df2 = zeros(size(M,1), 2);
    for i = 1:size(M, 1)
        matched_df1(i,:) = df1(M(i,1),1:2); % We slice 1:2, df(:,3) is arbitrary
        matched_df2(i,:) = df2(M(i,2),1:2);
    end
    % paris is a nx4 matrix with matched df1 df2 coordinates ready for
    % triangulation
    return
end

function distances = dist2line(df1,df2,F)
    % Standard formulat for calculating the distance between a point and a
    % line in 2D. Rexpressed in matrix form to return the matrix of all
    % distances between lines from df1*F and df2
    abc = df1*F; % ax+by+c = 0. Solution is in matrix form
    distances = abs( (abc(:,1)'.*df2(:,1)) + (abc(:,2)'.*df2(:,2)) + abc(:,3)' ) ./ sqrt( (abc(:,1)').^2 + (abc(:,2)').^2 );
    % distances matrix will be a matrix of size(df2,1) x size(df1,2)
    % Each col represents the distances between the nth line (df1(n)*F) and
    % each point in df2
    return
end

function y = fund(v, F, x) %#ok<DEFNU> 
    abc = v*F; % ax+by+c = 0
    a = abc(1);
    b = abc(2);
    c = abc(3);
    y = ((-x.*a) - (c)) / (b);
    return
end


% df1 = [1,2,1;
%        4,-3,1;
%        2,2,2];
% 
% F = [1,3,1;
%      2,2,2;
%      1,1,3];
% 
% df2 = [-1,0,1;
%        0,0,1;
%        1,0,1];

% hold on
% grid on
% x = linspace( (min(df2(:,1))-2) , (max(df2(:,1))+2) ,10000);
% for i = 1:size(df1,1)
%     y = fund(df1(i,:),F,x);
%     plot(x,y,'LineWidth',3)
% end
% plot(df2(:,1),df2(:,2),'b*', 'LineWidth',5)